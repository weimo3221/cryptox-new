# eval/metric_lib/metric_mbpp.py
# Python Standard Library
import multiprocessing
import re


async def multichoice_openai(response, test):
    """
    The asynchronous request makes a judgment about whether the code block can be executed correctly test
    """
    try:
        response_specific = extract_code(response)
        score = run_tests(response_specific, test)
        return score
    except Exception as e:
        print(f"Error processing response: {response}\nError: {e}")
        return 0, "error"
    

def extract_code(text):
    """
    Extract the last function block from the response, starting with "def" and ending with "return," while disregarding any "return" statements found within comments.
    """
    # 1.  First, prioritize searching within Markdown code blocks.
    code_blocks = re.findall(r"```(?:python)?\s*([\s\S]*?)```", text, re.IGNORECASE)
    if code_blocks:
        text = code_blocks[-1].strip()
    
    # 2. Locate the last `def` function.
    matches = list(re.finditer(r"def\s+\w+\s*\(.*?\):", text, re.MULTILINE))
    if not matches:
        return ""
    
    start = matches[-1].start()
    func_text = text[start:]
    
    # 3. Locate the final, non-commented return statement.
    lines = func_text.split('\n')
    return_line = -1
    for i, line in enumerate(lines):
        stripped = line.strip()
        if stripped.startswith('return '):
            return_line = i
        elif stripped.startswith('#'):
            continue
    
    if return_line == -1:
        return func_text.strip()
    
    # 4.  Extract the code block starting with "def" and ending with the final "return" statement.
    return '\n'.join(lines[:return_line + 1]).strip()


def run_tests(code, test_cases, timeout=3):
    """
    Test that the code executes test_list correctly
    """
    # Using shared variables to share success_count and failure_count across processes
    success_count = multiprocessing.Value('i', 0)  # 'i' indicates an integer type
    failure_count = multiprocessing.Value('i', 0)  # 'i' indicates an integer type

    def execute_code(test_case, success_count, failure_count):
        # Execute the code in this function
        # Execute the function definition code
        exec(code, globals(), locals())
        
        if test_case.strip():  # Skip empty lines
            try:
                exec(test_case, globals(), locals())
                with success_count.get_lock():  # Using locks to secure modifications
                    success_count.value += 1
            except AssertionError:
                with failure_count.get_lock():  # Using locks to secure modifications
                    failure_count.value += 1
                print(f"Test failed: {test_case}")
            except Exception as e:
                with failure_count.get_lock():  # Using locks to secure modifications
                    failure_count.value += 1
                print(f"Test failed due to error: {test_case}\nError: {e}")

    # Start the child process
    processes = []
    for test_case in test_cases:
        process = multiprocessing.Process(target=execute_code, args=(test_case, success_count, failure_count))
        processes.append(process)
        process.start()

    # Wait for all child processes to complete, limit timeout
    for process in processes:
        process.join(timeout)
        if process.is_alive():
            print(f"Code execution timed out after {timeout} seconds")
            with failure_count.get_lock():  # Using locks to secure modifications
                failure_count.value += 1
            process.terminate()  # Forced termination of sub-processes
            process.join()  # Ensure that the process is completely terminated

    # Printing the final test results
    return success_count.value / len(test_cases)


if __name__ == '__main__':
    # Code generated by the model (assuming this is the response fetched from the larger model)
    response = """Let me solve this step by step.\n\n1) First, let's understand what a centered hexagonal number is:\n   * Centered hexagonal numbers are numbers that represent hexagons with a dot in the center and dots surrounding it in layers\n   * Each layer adds points in a hexagonal pattern\n   * The sequence goes: 1, 7, 19, 37, 61, 91, 127, 169, 217, 271, ...\n\n2) Looking at the pattern:\n   * From 1 to 7: difference is 6\n   * From 7 to 19: difference is 12\n   * From 19 to 37: difference is 18\n   * From 37 to 61: difference is 24\n   We can see each difference increases by 6\n\n3) Let's derive the formula:\n   * For the nth centered hexagonal number, each layer adds 6 more points than the previous layer\n   * The formula turns out to be: 3n(n-1) + 1\n   * Where n is the position in the sequence\n\n4) Let's write the function:\n\n```python\ndef centered_hexagonal_number(n):\n    return 3*n*(n-1) + 1\n```\n\n5) Verify the test cases:\n   * For n=10: 3*10*9 + 1 = 270 + 1 = 271 ✓\n   * For n=2: 3*2*1 + 1 = 6 + 1 = 7 ✓\n   * For n=9: 3*9*8 + 1 = 216 + 1 = 217 ✓\n\nAnswer: def centered_hexagonal_number(n): return 3*n*(n-1) + 1"""
    # Test Case List
    test_list = ["assert centered_hexagonal_number(10) == 271",
        "assert centered_hexagonal_number(2) == 7",
        "assert centered_hexagonal_number(9) == 217"
    ]
    # operational test
    response = extract_code(response)
    print(response)
    print(run_tests(response, test_list))
